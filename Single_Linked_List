# 2021_DA_in_CPP
2021년 자료구조 근본찾기 프로젝트

====================
링크드 리스트

: 데이터 & 포인터 한 쌍을 node 라고 부른다.
: 각 노드와 노드는 head 부터 tail 까지 포인터로 인간지네처럼 연결되어 있다.
: 데이터는 int 뿐만 아니라 string, class, 무슨 객체든 될 수 있다.

====================
코딩

:한 노드를 구현하기 위한 클래스와, 전체 링크드 리스트를 구현하기 위한 전자의 프랜드 리스트 2개로 구현된다.

1. 노드 클래스

: 크게 어려울 것 없이, 포인터 하나와 데이터 하나로 구성한다.
: 전체 리스트를 컨트롤하기 위한 클래스를 프랜드 클래스로 선언한다.

2. 링크드 리스트 클래스

: 전체 컨트롤을 위한 링크드 리스트 클래스다.
: private 영역에는 head와 tail 의 주소가 따로 기록되어 있다.
: tail 은 필요에 따라 추가된 것으로, 책에서는 head 만 지니고 있는 듯.
: public 영역에는 생성자와 소멸자를 비롯한 각종 메서드들이 자리한다.


2-1. 메서드들

empty() : boolean 으로 emplty 여부를 반환하는 메서드
front() : head 의 element 를 반환하는 메서드

그리고 head & tail 에서의 삽입 & 삭제 동작 총 4가지.

========================
Head 에서 삽입 

: 새로운 node가 node* v 에 할당된다.
: v 에 데이터가 들어가고, v의 포인터에는 기존 head(=노드포인터)가 할당된다.
: v 가 head 에 대입되면서 새로운 head 추가가 완료된다.

*예외처리 : 링크드 리스트가 비어있다면, tail = v 이어야 한다.

=======================
Head 에서 삭제

: 우선 node* temp 에 기존 head의 주소를 담는다. (나중에 삭제하기 위함)
: head = head->next 를 통해 head를 교체한다.
: temp 에 담긴 노드를 delete 처리 한다.

*예외처리
상황 1) empty() = 1 이라면, 아무 동작을 하지 않아야 한다. 
상황 2) 삭제 이후 empty() = 1 인 경우
ㄴ> head->next = NULL 이었다. 기본 알고리즘에 의해 새로운 head 는 NULL이 되지만, 
ㄴ> 원래 Head 에서 삭제에 영향받지 아니하는 tail 을 NULL 로 만들어 주는 처리가 필요하다.

======================
Tail 에서 삽입

: Head 에서 삽입과 마찬가지로, 새로운 노드가 임시로 동적할당된다.
: tail->Next 위치에 새로운 노드가 자리를 잡고, 새로운 tail 이 된다.


*예외처리
: empty()=1 에서 삽입이 이루어질 경우, tail 을 업데이트 하면서 head = NULL 이었던 것 역시 수정해 주어야 한다.

===================
Tail 에서 삭제

기존 tail 노드는 temp에 따로 보관되었다가 이후 삭제된다.

하지만, tail -1 번째 node 를 찾기 위해서는 N 개의 데이터를 전부 순회하며 끄트머리를 일일히 찾아야 한다.

: current 노드가 head 에서부터 출발한다.
: while 문을 순회하며, current->next->next == NULL = 1 까지 나아간다.
: 발견하면, current->next = NULL 로 만든 뒤, tail 을 새로 설정해주고 temp 를 삭제한다.

*예외처리
상황1) empty()=1 에서는 아무 동작을 하지 않는다.
상황2) 삭제 이후 empty() =1 의 경우, 초기에 head = tail 인 경우로 확인하여 모두 NULL 처리한 뒤 temp 를 삭제한다.

====================
