# 2021_DA_in_CPP
2021년 자료구조 근본찾기 프로젝트

이 문서는 진짜 기초지식을 다 적는다기보다, 놓쳤을 수도 있을법한, 하지만 중요한 것들에 대한 이야기다.



----
NULL의 사용
<cstdlib> : 이 라이브러리를 include 해야만 쓸 수 있다.
  
ASCII 코드 값 0인 상수이다.

----
자료형의 크기

모든 자료형의 용량은 sizeof(obj)를 쉘? 에 실행시켜봄으로써 확인할 수 있다.

----

enum 자료형:

enum Day = {SUN, MON, TUE ... SAT} : 선언

0.enum 으로 하여금 Day 라는 형태의 자료형을 사용자가 하나 정의한 셈이다.

1. 모든 형태의 enum 객체들은 초기에 정의된 집합 안의 한정적인 값들만 가질 수 있다.
2. 이들 객체들은 하나의 정수처럼 동작한다. 기본적으로 0부터 step = 1, 인덱스 순서대로, 값이 주어진다.
3. 하지만, 초기에 enum Day = {SUN = 7, ... }과 같이 정의하여 값을 직접 지정해 줄 수 있다.

---

포인터와 구조체

struct Dude
{
  string name;
  unsigned int age;
}





Dude* P = new Dude;
ㄴ> P는 Dude 구조체 Kim 의 주소를 지니고 있다.

Dude.name
(*P).name  //이것이 본래 구조체의 멤버에 접근하는 방식이다. 허나 P를 사용하면..

P->name //포인터를 사용한 멤버 접근은 이렇게 해야 한다.

delete P 로 동적할당을 해제하는 것을 잊지 말자.

---
형변환

C 스타일:
int alpha = 5;
double Beta = (double)alpha;

C++스타일:
int alpha=5;
double Beta = double(alpha);
ㄴ>python 의 ''.join(list) & list(string)가 생각나는 부분이다. 함수형 형변환이라고도 한다.

---
제어문

switch(trigger)
  case1:
  
  case2:
  ...

위와 같이 동작하는 조건문. trigger 는 enum 변수도 될 수 있다.

---
참조 매개변수

1. 대형 구조체를 크기 그대로 매개변수로 전달하는 것은 비효율적이다. 주소로 전달하는 것이 낫다.
2. 매개변수는 원본을 수정하지 않는 방향으로 만들어지는 것이 옳다.

결론 : 참조자를 매개변수로 전달한다.

---
배열 매개변수

배열의 이름 = 첫번째 원소의 주소 이다. 따라서 배열은 값으로 전달되지 아니한다.

출력 역시 마찬가지다. 포인터만이 전달된다.

명시적으로 포인터의 출력을 표시하거나, vector 배열을 놓는 것이 옳다.

---
메서드의 선언과 정의

class Passenger
{
  T Getname() const; //선언  
}

T Passenger::Getname() const
{
  //정의
}

const 의 위치를 잘 확인하자.

----
복사, 생성, 소멸의 디폴트

Passenger A;
Passenger B = A;

:위의 방법은 위험하다. 연산자 오버로딩이 있지 않다면 A의 멤버 값들만이 B로 복사된다. 
만약 Passenger 클래스가 포인터를 사용한다면, 얕은복사가 일어나는 것이다.
//////
new 를 사용하여 어떤 포인터의 주소에 클래스를 하나 할당하였다고 하자.
이 첫 순간에 생성자가 호출되며, delete 로 해제될 때 소멸자가 호출된다.

정적할당의 경우, 해당 영역이 끝날 때 소멸자가 호출된다.

---
프랜드 클래스&함수

A 클래스 내부에 friend class B 를 선언하여 B의 메서드들이 A의 private 영역에 접근할 수 있게 할 수 있다.

함수 역시 마찬가지. 출력 T 앞에 friend 를 붙여 클래스 내부에 선언하면,

메서드가 아니어도 private에 접근할 수 있는 함수를 만들 수 있다.

---







