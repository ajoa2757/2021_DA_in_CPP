# 2021_DA_in_CPP
2021년 자료구조 근본찾기 프로젝트

ADT : 'Abstract' data structure, 추상적 자료구조.

ADT 라는 단어 자체는 사용자 입장에서의 설명이다.

ex)마치 주식계좌와 같은 자료구조, 하스스톤 덱 과 같은 제료구조, 음식점 주문 줄과 같은 자료구조, 뭐그런 식.

이런 식의 설명은, 작동의 방향성만을 평가하는 관점의 설명이다. Big O notation 같은 부분은 고려하지 않아도 좋다는 이점이 있다.



=================
Stack

흔히 생각하는 하스스톤의 덱과 같다.

가장 나중에 올린 카드가 가장 먼저 나온다 ==> Last in First out, "LIFO"

top() : 가장 위의 데이터.
size() : 스택의 크기.

push() : 스택의 가장 위에 데이터를 추가한다.
pop() : 스택의 가장 위에 있는 데이터를 제거한다. 
ㄴ>top() 을 사용하여 반환하는 T pop() 이 있고, 그런것 없는 void pop() 도 있다.
ㄴ>empty() =1 의 경우 stdl 의 예외객체를 throw 한다.
================
함수 스택

이 stack 과 같은 형태를 가진 것이 바로 C++의 함수 스택이다.

main 이라는 가장 밑바닥의 함수를 시작으로, PC 라는 레지스터에 순서가 기록된다.

함수가 다른 함수를 호출할 때마다 그들은 +1 된 PC 를 가지며, 

함수가 풀어지는(실행되는) 순서는 이 PC 를 따른다. 가장 나중에 호출된 함수가 먼저 풀린다는 점은 stack 과 같다.


=================
stack 과 예외처리 

1.throw

사실 배웠었지만, 다시한번 복습한다.
 
여기 템플릿 자료형 T 를 리턴하는 함수 Algo 가있다. 

이 함수가 아무것도 리턴하지 못하는 상황이 존재할 수 있지 않은가?
ㄴ>가령, 빈 stack 에서의 pop.

이때, if 문 내부에 throw 를 해 주면, 예외 상황 발생 시 T 대신 throw 된 객체를 리턴하게 된다.


2. try & catch

try 이후에 throw 가 처음 발생하면, 함수 스택은 catch 가 가장 처음 발생하는 지점까지 내려간다.

이후 

catch(exception e)
{
}

가 실행된다.


이때, catch 까지 내려가면서 모든 함수 스택이(지역변수들을 포함하여) 모두 정상적으로 해제된다.

================
Queue

은행의 줄과 같은 형태의 ADS 이다. 먼저 줄에 들어간 데이터가 가장 먼저 나온다. -> First in, First out. "FIFO"

front : 맨 앞
rear : 맨 뒤. 가장 나중에 들어온 데이터.

enqueue : 삽입 메서드
dequeue : 삭제 메서드


================
배열에서의 구현


정해진 크기의 배열을 환형적으로 사용한다.

enqueue / dequeue 를 하였을 때 맨 앞이 [0] 인 형태를 유지하려면, 둘 다 O(N) 만큼의 수행시간이 든다.

하지만, 이러한 작업 없이 환형적으로, 맨 뒤가 다 찼으면 빈 공간이 있는 맨 앞부터 queue 를 쌓아가면

기억하고 있는 front/rear 의 인덱스를 가지고 상수 시간 안에 수행할 수 있다.

*
링크드 리스트 역시 tail 과 head 를 기억하는 유형의 자료구조이다. 

링크드 리스트로 queue 를 구현하는것이 상당히 효율적이다. 포인터의 4바이트가 노드마다 추가되지만, 결국 상수 시간만큼이므로 O(N) 이다.

================
deque

Double-Ended queue => DE queue => deque 이다. 덱 이라고 한다. 하스스톤의 그 덱이다.

앞과 뒤 모두에서 pop/push 가 가능해서, 해당 메서드가 총 4개이다.





