# 2021_DA_in_CPP
2021년 자료구조 근본찾기 프로젝트

그래프 자료구조에 대한 기초적인 내용.


V(G) : 그래프의 Element 들을 단순하게 나열한 것.

E(G) : Graph 의 Edge 를 말한다. 이때 Edge 는 그래프의 모든 연결관계를 말하는 것이다.
ㄴ>소괄호 (e1, e2) 는 양방향 연결관계를 말한다.
ㄴ>중괄호 <e1, e2> 는 e1 -> e2 로 가는 단방향 연결관계를 말한다.

1. 스스로에서 스스로로 가는 연결은 단방향이든 양방향이든 허락되지 않는다.
2. 같은 연결이 여러번 정의될 수는 없다.
ㄴ> 허나, e1 과 e2 사이의, 서로 반대 방향의 단방향 연결이 2개 존재할 수는 있다.


- Complete Graph 

ㄴ> n 개의 원소가 존재한다.
ㄴ> 가능한 모든 Edge 가 연결되어 있다.
ㄴ> 다만 이때, Directed / Undirected 에 따라 연결의 개수가 n(n-1) 또는 n(n-1)/2 로 나뉜다.



- Adjecent : 인접해 있다. 둘 사이에 Edge 가 존재하면 Adjecent 하다고 판정한다.
- incedent : 포함한다. Edge 는 두개의 정점을 포함한다.

- Subgraph : Graph G1 이 지니고 있는 모든 Edge 와 Vertices 를 Graph G2 가 지니고 있다면, G1 은 G2 의 Subgraph 이다.


Path

- Edge 를 따라서 Vertices 를 순회하는 작업을 의미한다.
- 단방향 Edge 를 지나고자 할땐 반드시 방향이 맞아야 한다. 양방향은 무조건 오케이.
- Cycle : 시점과 종점이 같은 Path
- Simple Path : 시점과 종점이 다른 Path
- Directed : 방향성을 지니고 있는 Path 를 의미한다.


연결성

- Connected : 만약 Undirected Graph 에서 모든 점 사이에 둘 사이의 경로가 존재한다면 그래프가 연결되어 있다고 한다.
- Strongly Connected :  만약 Directed Graph 에서 모든 점 사이에 단방향 Path 가 존재한다면 그래프가 연결되어 있다고 한다.
ㄴ> 만약 점 하나만 덩그러니 존재하는 Graph 라면 그것 역시 연결되어 있는 것으로 친다


- Degree : 어떤 점이 가지고 있는 연결의 개수
- in-Degree : Directed Graph 에서, 어떤 점 v 가 시작점이 되는 Edge 의 개수
- out-Degree : 반대로 점 v 가 꼬리가 되는 Edge 의 개수


Tree : 말하자면 단방향, 비순환성 그래프라고 하겠다.
ㄴ> 영어로 Acyclic Connected Graph 라고 부른다


Adjacency Matrix : 연결 매트릭스. 그래프의 연결 상태를 정의한다.
ㄴ>각 연결 adjact[i][j] 는 정점 i 에서 정점 j 로 가는 Edge 의 존재 여부를 나타낸다.

Adjacency list : 각 정점들은 리스트를 하나씩 지닌다.
ㄴ>각 노드들은 정점을 나타내는 int 하나를 데이터로 지닌다.
ㄴ>이러한 노드포인터의 배열이 곧 Graph 가 된다.
ㄴ>그리고 이것의 배열 순서는 관계가 없다.

Edge Structure : Edge 하나를, 멤버 변수 int 두개 v1, v2 를 가지도록 하여 나타낸다.


Weighted Graph : Edge 들에 int 형태의 가중치가 붙은 그래프를 이야기한다.
ㄴ> 추상적으로 표현하자면, 도시 사이의 거리를 Edge 의 가중치 형태로 나타낼 수 있겠다.


Graph 순회


1. Depth first search - DFS

- 우선, 그래프 자체는 Adjacency list 로 기술되어 있다고 하자.
- 전역 배열을 하나 선언한다. 여기에 이미 방문한 vertices 를 기록한다.

- Adjacency list 를 읽으면서, 링크를 따라 반복문이 순회한다. 만약 링크를 모두 읽었으면 함수 종료.
- 읽으면서, 만약 지금 읽고 있는 그래프 원소가 한번도 방문한 적이 없는 노드라면, 함수를 재귀호출한다.

이런식으로 한다면, 모든 격자가 어떻게든 연결만 되어 있다면 전체순회를 하게 되어 있다.

흐름 : 링크 따라서 진행 -> 딴길로 새기 -> 방문배열 계속 업데이트 -> 딴길에서 다시 본길로 돌아오는건 나중의 일


2. Breadth First search - BFS

- 동적할당된 linked_queue 를 하나 생성한다.
- 각 queue node 하나는 격자 하나의 데이터와 link 를 보관한다.

- 우선, 한 개의 노드를 전부 순회한다.
- 순회하는 과정에서, 만난 노드가 처음 만나는 노드라면..
- queue 에 push 하고, visited 처리 한다.

- 만약 이미 만났던 노드라면 아무런 조치를 취하지 않는다.
- 이런식으로 모든 연결되어있는 노드들을 순회할 수 있다.

흐름 : 딴길로 새지 않고 링크따라서 진행 -> 딴길은 방문하지 않고 queue 에 저장해놓기 -> 한 노드 순회가 끝나면 queue 를 기준으로 새로운 순회


연결 여부 확인하기

-dfs 를 한번 할 때마다 visited 는 업데이트 된다. 하지만 이 업데이트란 무엇인가?
ㄴ> 본질적으로 모든 노드를 업데이트 해주는 것과는 다르다.
ㄴ> dfs 를 하면, 모든 서로 연결되어있는 노드들을 방문할 뿐이다. 그말인 즉슨 연결이 없는 노드는 방문하지 아니한다는 것이다.

-만약 모든 노드를 따라 순회하면서 방문 여부를 확인하고 dfs 를 실시하는데, dfs 가 두번 이상 실행된다면 그 그래프는 한붓그리기가 불가능한 그래프이다.

이러한 프로세스가 connected 함수라고 한다면, 그래프의 크기가 상수라고   

Spanning trees

- 우리가 dfs 또는 Bfs 와 같은 방법을 사용하여 그래프를 순회했다고 하였다고 하자. 
- 순회 경로는 edge 들을 따라서 그려질 것이다.

- 그런데 이 경로 edge들은, 사실 모든 edge 들을 포함하지 않아도 될 것이다.
- 이것은 최상위 노드를 기준으로 그 연결을 따라 그려져있는 하나의 Tree 자료구조와 같은 형태가 될 것이다.

- 이때 경로 Edge 들을 T 라고 부르고, 경로에 포함되지 못한 Edge 들을 N 이라고 부르기로 한다.
- 그리고 T Edge 들로 하여금 그려진 트리를 Spanning Trees 라고 부른다.


+ 이 Spanning Tree 는 일방통행식으로 만들어졌다. 만약 여기에 하나라도 N Edge 를 추가한다면 그것은 Cycle 의 형태가 될 것이다.
+ 수학적으로 T Edge 의 개수는 그래프 내부 격자의 개수 N 에 대하여 무조건 N-1 이다.
+ T Edge 들로 만들어진 그래프는, 원본 그래프 G 의 Subgraph 이다.


Biconnected Graph 

- 어떤 한 점을 제거하여도 그래프가 두 쪽이 나지 않는 그래프를 Binconnected Graph 라고 부른다
- 만약, 어떤 그래프가 제거되었을 시 그래프가 두쪽이 나버리는 점을 가지고 있다고 하자. 그 점을 단절점이라고 한다.
- 그 점을 Articulation Point 라고 한다.
ㄴ> 이 "두 쪽이 나다" 의 최소기준은 1개의 격자 + @ 이다.

Biconnedted Components

- 단절점이 있는 그래프가 있다.
- 이 그래프 내부에서도, 어떤 Subgraph 는 Biconnected Graph 의 모습을 하고 있을 수 있다.
- 이러한 Subgraph 들을 Biconnected Components 라고 부른다.



Minimum - Cost Spanning Tree

- 여기서 Cost 란, Weighted Graph 의 Edge 들에 주어진 가중치를 이야기 한다.
- Greedy 알고리즘을 사용하는 Case 이다. 즉 순간순간 가장 낮은 가중치의 방향으로 향하면 되겠다.

크루스칼 알고리즘 
- Heap(=힙 조건을 갖춘 이진탐색트리) 에 Edge 들을 차례로 담는다.
- Heap 에서 Edge 를 하나씩 불러와서 가중치를 더하던 배열에 담건 한다.
- 만약, 불러온 Heap 이 원래의 구조와 Cycle 을 만든다면, discard 한다.
- 이렇게 n-1 개의 Edge 에 대하여 동작을 취하면 끝이다.

- 한마디로, 크루스칼 알고리즘은 최소 가중치 기준으로 Edge 를 하나씩 불러와서..
- Cycle 이 안되는 조건으로 n-1 개의 Edge 를 불러오면 무조건 최소경로가 나온다는 논리이다.

Prim 알고리즘
- 주인공 격자 하나를 포함하는 T tree 로 시작한다. 
- 이 격자가 포함되는 최소 크기의 Edge 로 진행한다. 이제 옮겨온 걱자가 새로운 주인공이다.
- 그 다음 격자는, 주인공이 가지고 있는 가장 최소의 Edge 방향으로 탐색하여 찾는다.

- 한번 방문했던 격자는 주인공이 될 수 었다. 이 부분을 매 반복마다 조건문으로 탐색한다.
- n-1 개의 Edge 가 완성될 때 까지 반복한다.



Shortest Paths

- Spanning Tree 의 조건은, 모든 격자를 순회하는 어떤 set of Edges 를 만들어내는 것 이었다.
- 이번에 만들어내고자 하는 것은, 두 격자를 잇는 가장 짧은(=weight sum 이 가장 작은) Edge 의 set 를 만들어내는 것 이다.

- 시작 격자 v0 로부터의 path 를 찾는 함수가 distance(w) 라고 하겠다.

S : S 는 v0 로부터 Shortest Path 가 찾아진 격자들의 집합이다.

- 새로운 격자 u 를 S 에 포함시키려면, distance(u) 를 찾아야 한다고 하겠다.
- 만약 이 "최소 경로" 라는 것이 S 안에 포함된 격자들만의 경로를 말하는 것이라면, u 가 추가되는 것이 새로운 최소 경로의 가능성을 만든다.

- Ak 라는 매트릭스가 있다. 이 2차원 매트릭스 안에 격자 i 에서 j 로 가는 최단 경로의 Cost 가 기록된다.
- 다만 이 Ak 는, k 번째 이상의 격자는 포함시키지 않는다 (즉, k= -1 이면 본인만 포함)
- A0 로부터 시작해서 An-1 까지 모든 격자들의 모든 경로 비용을 알려주는 2차원 배열을 완성시키는 것이 목표이다.
ㄴ> 아직 발견되지 않은 경로는 cost 를 무한대로 치부하도록 한다.
ㄴ> 모든 Ak 는 일단 크기 자체는 N x N 을 가지고 있다.

- Ak-1 을 기반으로 만들어진 Ak 를 보자.
- Ak = Ak-1 일수도 있다.
- 새롭게 포함된 격자 k 를 사용한 더 짧은 경로가 추가되었을 수도 있다.
 
 
 * 반복문을 사용한 Ak 완성 알고리즘
 : 우선 모든 Edge 들의 가중치가 Distance 에 기록된다
 : k, i, j 라는 3차원에 걸친 반복문이 실행되면서, distance[i][j] 와 distance[i][k] + distance[k][j] 가 비교된다
 : 최 외곽의 k 반복문이 실행되면서, 한 차원씩 Ak 가 확장된다.
 : k 가 하나 편입될때마다, 모든 [i][j] 경로가 k 에 의한 영향이 생기는지 아닌지를 검사받는 개념.
 

 
 
 AOV : activity on vertex Network
 
ㄴ> 유향 그래프를 사용하여 나타낸 어떤 네트워크이다.
ㄴ> 가령, 각 격자들이 대학교의 강의들이라고 해 보자.
ㄴ> 유향 그래프를 사용한 관계로, 각각이 선수과목으로써 연결된 다양한 강의들의 모습을 하고 있을 수 있다.

- predecessor : i 가 선수과목, j 가 그 이후 수강 과목 이라고 하자. 
ㄴ> i 는 j 의 predecessor 이다.
ㄴ> j 는 i 의 successor 이다.
ㄴ> 이때 둘이 한 Edge 로 직접 연결되어 있다면, 둘을 immediate Prede/successor 라고 한다\

- Transitive : 둘이 어쩄든 연결되어 있는 상황
- irreflexible : 

....

Topological order : 모든 격자를 Linear 하게 늘어놓은 것.
- Predecessor 들의 순서가 무조건 Successor 보다 앞선다.

- 격자 하나를 Pop 하고, 그 Successor 들 중에서 Predecessor 가 하나도 남지 않은 격자부터 또다시 POP 하는 식.
- 격자들은 연결 리스트 형태로 Edge 들을 기술하고 있다고 전제한다.

 ㄴ> 반복문을 통해 Predecessor 가 없는 최초의 조상 노드를 찾을 필요가 있다.
 ㄴ> top 을 출력하고, 반복문을 통해 새로운 top 을 찾는 것을 기본 골자로 한다.
 
 
AOE : 위의 AOV 에서, 이번엔 Task 의 추상적 역할을 Edge 가 도맡아 한다. 그래프의 기본 구조는 유항-가중그래프이다.

ㄴ> 각 격자들은 특정 task(=Edge) 가 완료된 어떤 상태를 의미하게 된다.
ㄴ> 가중치가 0 인 Edge 는 dummy activities 라고 부른다.

critical path : Shortest Path 와 같은 맥락이다.
ㄴ> 단 이때는, 프로젝트 시작과 끝 node 가 정해져 있으므로 그 둘의 경로라고 하겠다.

 
 late(i) : 어떤 상태 vi 에 도달하기 위한 가장 늦은 시간.
 early(i) : 어떤 상태 vi 에 도달하기 위한 가장 빠른 시간.
 
 Critical Activity : 위의 두 함수가 서로 같은 격자 i 
 
 





